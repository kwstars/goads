List 是一个有序的集合，可以包含重复的元素。List 支持基于索引的数据访问，允许按照元素在列表中的位置进行精确的定位和操作。你可以获取列表的任何位置的元素，可以在任何位置插入元素，也可以从任何位置删除元素。

## 实现列表（List）的底层数据结构主要有以下几种：
### 数组（Array） 
- 优点：查找元素（通过索引）非常快，时间复杂度为O(1)；数组在内存中是连续的，空间利用率较高。 
- 缺点：插入和删除元素（特别是在数组的中间位置）需要移动大量的元素，时间复杂度为O(n)；数组的大小是固定的，不能动态扩展。 
- 适用场景：需要频繁进行随机访问的场景，如实现某些排序算法，或者问题本身具有随机访问的特性。

### 动态数组（如Java中的ArrayList、Python中的list）
- 优点：查找元素（通过索引）依然非常快，时间复杂度为O(1)；可以动态扩展。 
- 缺点：插入和删除元素（特别是在数组的中间位置）需要移动大量的元素，时间复杂度为O(n)；扩容时需要复制所有的元素到新的数组。 
- 适用场景：既需要动态扩展，又需要频繁进行随机访问的场景。

### 链表（Singly LinkedList）
- 优点：插入和删除元素非常快，时间复杂度为O(1)（如果已知节点）；链表的大小是动态的，可以根据需要扩展。 
- 缺点：查找元素需要从头节点开始遍历，时间复杂度为O(n)；链表在内存中是分散的，空间利用率较低。 
- 适用场景：需要频繁进行插入和删除操作的场景，如实现堆栈、队列等。

**size**: 是为了方便获取链表的长度，如果不需要获取链表的长度，可以不用维护 `size`。

**sentinel node（哨兵节点）**: 是为了方便操作链表的头节点和尾节点，如果不需要操作头节点和尾节点，可以不用维护 sentinel node。

### 双向链表（Doubly LinkedList）
- 优点：同链表，插入和删除元素非常快，时间复杂度为O(1)（如果已知节点）；双向链表可以从两个方向遍历，提高了查找的效率。 
- 缺点：查找元素仍需要遍历，时间复杂度为O(n)；需要额外的空间存储前驱节点的指针。 
- 适用场景：需要频繁进行插入和删除操作，且需要从两个方向遍历的场景，如实现双端队列等。
