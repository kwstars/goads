## 定义

List 是一个有序的集合，可以包含重复的元素。List
支持基于索引的数据访问，允许按照元素在列表中的位置进行精确的定位和操作。你可以获取列表的任何位置的元素，可以在任何位置插入元素，也可以从任何位置删除元素。

## 列表（List）的底层数据结构实现

### 数组（Array）

- 优点：查找元素（通过索引）非常快，时间复杂度为O(1)；数组在内存中是连续的，空间利用率较高。
- 缺点：插入和删除元素（特别是在数组的中间位置）需要移动大量的元素，时间复杂度为O(n)；数组的大小是固定的，不能动态扩展。
- 适用场景：需要频繁进行随机访问的场景，如实现某些排序算法，或者问题本身具有随机访问的特性。

### 动态数组（如Java中的ArrayList、Python中的list）

- 优点：查找元素（通过索引）依然非常快，时间复杂度为O(1)；可以动态扩展。
- 缺点：插入和删除元素（特别是在数组的中间位置）需要移动大量的元素，时间复杂度为O(n)；扩容时需要复制所有的元素到新的数组。
- 适用场景：既需要动态扩展，又需要频繁进行随机访问的场景。

### 链表（Singly LinkedList）

- 优点：插入和删除元素非常快，时间复杂度为O(1)（如果已知节点）；链表的大小是动态的，可以根据需要扩展。
- 缺点：查找元素需要从头节点开始遍历，时间复杂度为O(n)；链表在内存中是分散的，空间利用率较低。
- 适用场景：需要频繁进行插入和删除操作的场景，如实现堆栈、队列等。

**为什么 List 中添加 size 变量?**

- 为了方便获取链表的长度，如果不需要获取链表的长度，可以不用维护 `size`。

**为什么需要维护 sentinel node（哨兵节点）?**

- 对于一些常见的链表操作，比如插入节点、删除节点等，无论这些操作是在链表的开始、中间还是结束位置进行，都可以统一处理，无需为了处理链表的开始或结束位置而编写额外的代码。这大大简化了链表操作的实现，并降低了出错的可能性。

### 双向链表（Doubly LinkedList）

- 优点：同链表，插入和删除元素非常快，时间复杂度为O(1)（如果已知节点）；双向链表可以从两个方向遍历，提高了查找的效率。
- 缺点：查找元素仍需要遍历，时间复杂度为O(n)；需要额外的空间存储前驱节点的指针。
- 适用场景：需要频繁进行插入和删除操作，且需要从两个方向遍历的场景，如实现双端队列等。

双链表在处理某些操作时可能会遇到一些特殊的情况，例如在插入或删除节点时，如果要插入或删除的节点位于链表的头部或尾部，需要做一些特殊的处理，比如更新头节点或尾节点的引用。这种处理增加了代码的复杂性，并可能引入错误。为了避免这种特殊情况的处理，可以引入"哨兵节点"或"循环链表"。
- **两哨兵节点（Double Sentinel）**
  - 在这种方法中，我们在链表的头部和尾部都增加一个哨兵节点。这样无论在链表的头部、中间还是尾部插入或删除节点，都可以统一处理，因为每一个节点都有前驱节点和后继节点，无需担心会遇到空引用。
- **循环哨兵节点（Circular Sentinel）** 
  - 在这种方法中，我们使用一个哨兵节点，并使链表形成一个循环，即头节点的前驱是尾节点，尾节点的后继是头节点。这种方法同样可以使得在链表的头部、中间和尾部插入或删除节点的操作统一化，无需担心空引用。

